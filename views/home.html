<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>To-Do</title>

    <link href="../css/styles.css" rel="stylesheet" type="text/css" />

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.js"></script>
    <script src="//fb.me/react-with-addons-0.10.0.js"></script>
    <script src="//fb.me/JSXTransformer-0.10.0.js"></script>
</head>
<body>

    <header><h1>To-Do</h1></header>
    <section id="main"></section>
    <footer><a class="code" href="https://github.com/ktrain/todo-react/">The code</a></footer>

    <script type="text/jsx">
    /** @jsx React.DOM */

    // addons
    var ReactClassSet = React.addons.classSet;
    var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

    var List = React.createClass({
        getInitialState: function() {
            return { items: [], working: false, workingSince: 0 };
        },

        // on page load, grab list data
        componentDidMount: function() {
            $.get(this.props.source, function(result) {
                var items = [];
                result.map(function(item) {
                    items[item.index] = item;
                });
                this.setState({ items: items });
            }.bind(this));
        },

        componentDidUpdate: function(prevProps, prevState) {
            // when the working state blips, save the signal
            if (!prevState.working && this.state.working) {
                this.setState({ workingSince: Date.now() });
            }
        },

        addItem: function(newItemData, callback) {
            this.setState({ working: true });
            var items = this.state.items;
            newItemData.checked = newItemData.checked || false;

            $.post(this.props.source, newItemData, function(data) {
                items[data.index] = data;
                this.setState({ items: items, working: false }, function() {
                    console.log('added new item', data);
                    if (typeof callback === 'function') {
                        callback(data);
                    }
                });
            }.bind(this));
        },

        removeItem: function(index) {
            this.setState({ working: true });
            console.log('deleting items[' + index + ']');
            var removeTarget = this.state.items[index];
            if (!removeTarget) {
                console.log('no target');
                return;
            }

            $.ajax({
                type: 'DELETE',
                url: this.props.source + '/' + removeTarget.id,
                success: function() {
                    var items = this.state.items;
                    // TODO: promises
                    for (var i = index; i < items.length-1; i++) {
                        items[i] = items[i+1];
                        items[i].index--;
                        $.ajax({
                            type: 'PUT',
                            url: this.props.source + '/' + items[i].id,
                            data: items[i],
                        });
                    }
                    items.pop();
                    this.setState({ items: items, working: false });
                }.bind(this)
            });
        },

        updateItem: function(newData, callback) {
            this.setState({ working: true });
            console.log(newData);
            $.ajax({
                type: 'PUT',
                url: this.props.source + '/' + newData.id,
                data: newData,
                success: function(data) {
                    var items = this.state.items;
                    items[data.index] = data;
                    this.setState({ items: items, working: false }, function() {
                        if (typeof callback === 'function') {
                            callback(data);
                        }
                    });
                }.bind(this)
            });
        },

        reorderItem: function(reorderData, callback) {
            // TODO: promises
            //this.setState({ working: true });
            var initialIndex = reorderData.initialIndex, index = reorderData.index;
            var items = this.state.items;

            if (index < 0 || index >= items.length) {
                if (typeof callback === 'function') {
                    callback();
                }
                return;
            }

            console.log(items);

            var reorderedItem = items[initialIndex];

            console.log('moving ' + (initialIndex+1) + ' to ' + (index+1));

            if (index < initialIndex) {
                // item has been moved up; move down by 1 all items in between
                for (var i = initialIndex-1; i >= index; i--) {
                    items[i].index++;
                    items[i+1] = items[i];
                }
            } else if (index > initialIndex) {
                // item has been moved down; move up by 1 all items in between
                for (var i = initialIndex+1; i <= index; i++) {
                    items[i].index--;
                    items[i-1] = items[i];
                }
            }
            // update the moved item
            reorderedItem.index = index;
            items[index] = reorderedItem;

            this.setState({ items: items }, function() {
                if (typeof callback === 'function') {
                    callback();
                }
            });

            //this.setState({ working: false });
        },

        render: function() {
            // render items
            var renderedItems = [];
            var items = this.state.items;

            for (var i in items) {
                var item = items[i];
                renderedItems[item.index] = <Item key={item.id}
                    id={item.id}
                    index={item.index}
                    value={item.value}
                    checked={item.checked}
                    removeCallback={this.removeItem}
                    updateCallback={this.updateItem}
                    reorderCallback={this.reorderItem}
                />;
            }

            var showWorking = (Date.now() - this.state.workingSince) < 1000;

            return (
                <div className="list">
                    <ol>
                        {renderedItems}
                        <ItemNewField index={renderedItems.length} saveCallback={this.addItem} />
                    </ol>
                    <LoadingNotification show={showWorking} />
                </div>
            );
        }
    });

    var ItemNewField = React.createClass({
        getInitialState: function() {
            return { value: '' };
        },

        onKeyPress: function(evt) {
            if (evt.keyCode === 13) {
                this.save();
            }
        },

        handleChange: function(evt) {
            this.setState({ value: evt.target.value });
        },

        save: function() {
            if (!this.state.value) {
                return;
            }
            this.props.saveCallback({ index: this.props.index, value: this.state.value }, function() {
                this.setState(this.getInitialState());
            }.bind(this));
        },

        render: function() {
            return (
                <li>
                    <span className="number">{this.props.index+1}.</span>
                    <div>
                        <input
                        type="text"
                        className="new-field"
                        placeholder="New item"
                        onChange={this.handleChange}
                        onBlur={this.save}
                        onKeyPress={this.onKeyPress}
                        value={this.state.value} />
                    </div>
                </li>
            );
        }
    });

    var ItemField = React.createClass({
        getInitialState: function() {
            return {
                value: this.props.initialValue,
                editMode: false
            };
        },

        onKeyPress: function(evt) {
            if (evt.keyCode === 13) {
                this.save();
            }
        },

        handleClick: function(evt) {
            this.enableEditMode(function() {
                $(this.getDOMNode()).find('input[type="text"]').focus();
            }.bind(this));
        },

        enableEditMode: function(callback) {
            this.setState({
                editMode: true
            }, function() {
                if (typeof callback === 'function') {
                    callback();
                }
            });
        },

        disableEditMode: function() {
            this.setState({ editMode: false });
        },

        handleChange: function(evt) {
            this.setState({ value: evt.target.value });
        },

        save: function() {
            if (this.state.value == this.props.initialValue) {
                this.disableEditMode();
                return;
            }
            var newData = {
                id: this.props.id,
                index: this.props.index,
                value: this.state.value,
            };
            this.props.updateCallback(newData, function() {
                this.disableEditMode();
            }.bind(this));
        },

        renderDisplayMode: function() {
            return this.state.value;
        },

        renderEditMode: function() {
            return (
                <input
                    type="text"
                    className="value"
                    onChange={this.handleChange}
                    onBlur={this.save}
                    onKeyPress={this.onKeyPress}
                    value={this.state.value}
                />
            );
        },

        render: function() {
            var innards = (this.state.editMode) ? this.renderEditMode() : this.renderDisplayMode();
            var deleteButton = <ItemDeleteButton index={this.props.index} removeCallback={this.props.removeCallback} />

            return (
                <div className="field-wrapper" onClick={this.handleClick}>
                    {innards}
                    {deleteButton}
                </div>
            );
        }
    });

    var Item = React.createClass({
        render: function() {
            return (
                <li>
                    <ItemNumber initialIndex={this.props.index} reorderCallback={this.props.reorderCallback} />
                    <ItemCheckbox
                        id={this.props.id}
                        checked={this.props.checked}
                        updateCallback={this.props.updateCallback}
                    />
                    <ItemField
                        id={this.props.id}
                        index={this.props.index}
                        initialValue={this.props.value}
                        updateCallback={this.props.updateCallback}
                        removeCallback={this.props.removeCallback}
                    />
                </li>
            );
        }
    });

    var ItemNumber = React.createClass({
        getInitialState: function() {
            return {
                editMode: false,
                index: this.props.initialIndex
            };
        },

        onKeyPress: function(evt) {
            if (evt.keyCode === 13) {
                this.save();
            }
        },

        handleClick: function(evt) {
            this.enableEditMode(function() {
                $(this.getDOMNode()).focus();
            }.bind(this));
        },

        enableEditMode: function(callback) {
            this.setState({
                editMode: true
            }, function() {
                if (typeof callback === 'function') {
                    callback();
                }
            });
        },

        disableEditMode: function() {
            this.setState(this.getInitialState());
        },

        handleChange: function(evt) {
            var newIndex = parseInt(evt.target.value);
            newIndex = (newIndex >= 1) ? newIndex-1 : '';
            this.setState({ index: newIndex });
        },

        save: function() {
            if (this.state.index === '' || this.state.index == this.props.initialIndex) {
                this.disableEditMode();
                return;
            }
            var reorderData = {
                initialIndex: this.props.initialIndex,
                index: this.state.index,
            };
            this.props.reorderCallback(reorderData, function() {
                this.disableEditMode();
            }.bind(this));
        },

        renderEditMode: function() {
            var displayIndex = (typeof this.state.index === 'number') ? this.state.index+1 : '';
            return (
                <input
                    type="text"
                    className="number-editor"
                    onChange={this.handleChange}
                    onBlur={this.save}
                    value={displayIndex}
                />
            );
        },

        renderDisplayMode: function() {
            return (
                <span
                    className="number"
                    onClick={this.handleClick}
                >{this.props.initialIndex+1}.</span>
            );
        },

        render: function() {
            return (this.state.editMode) ? this.renderEditMode() : this.renderDisplayMode();
        }
    });

    var ItemCheckbox = React.createClass({
        handleChange: function(evt) {
            this.props.updateCallback({
                id: this.props.id,
                checked: this.refs.box.getDOMNode().checked
            });
        },

        render: function() {
            return (
                <input type="checkbox" ref="box" checked={this.props.checked} onChange={this.handleChange} />
            );
        }
    });

    var ItemDeleteButton = React.createClass({
        handleClick: function() {
            this.props.removeCallback(this.props.index);
        },
        render: function() {
            return <a className="remove" onClick={this.handleClick}>X</a>;
        },
    });


    var LoadingNotification = React.createClass({
        render: function() {
            var classes = ReactClassSet({
                'loading'   : true,
                'show'      : this.props.show
            });
            return (
                <div className="loading-container">
                    <div className={classes}></div>
                </div>
            );
        }
    });


    setInterval(function() {
        React.renderComponent(
            <List source="/api/items" />,
            document.getElementById('main')
        );
    }, 1000);
    </script>

</body>
</html>
